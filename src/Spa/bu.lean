import ring_theory.localization
import ring_theory.subring

import for_mathlib.nonarchimedean.basic
import for_mathlib.topological_rings -- subring of a top ring

import sheaves.presheaf_of_topological_rings
import continuous_valuations
import Spa.rational_open_data
import Huber_ring.localization

universes u‚ÇÅ u‚ÇÇ u‚ÇÉ

open_locale classical

open set function Spv valuation

local postfix `‚Å∫` : 66 := Œª A : Huber_pair, A.plus

variables {Œì‚ÇÄ : Type*} [linear_ordered_comm_group_with_zero Œì‚ÇÄ]

-- We reserve the name `Spa` (with upper case `S`) for the bundled adic spectrum (`adic_space.lean`)
/-- The space underlying the adic spectrum of a Huber pair (A,A‚Å∫)
consists of all the equivalence classes of valuations that are continuous
and whose value on the ring A‚Å∫ is ‚â§ 1. [Wedhorn, Def 7.23]. -/
definition spa (A : Huber_pair) : Type :=
{v : Spv A // v.is_continuous ‚àß ‚àÄ r : A‚Å∫, v (algebra_map A r) ‚â§ 1}

/--The equivalence class of a valuation is contained in spa
if and only if the valuation is continuous and its values on the ring A‚Å∫ are ‚â§ 1,
since these properties are constant on equivalence classes.-/
lemma mk_mem_spa {A : Huber_pair} {v : valuation A Œì‚ÇÄ} :
  Spv.mk v ‚àà {v : Spv A | v.is_continuous ‚àß ‚àÄ r : A‚Å∫, v (algebra_map A r) ‚â§ 1} ‚Üî
  v.is_continuous ‚àß ‚àÄ r : A‚Å∫, v (algebra_map A r) ‚â§ 1 :=
begin
  apply and_congr,
  { exact (out_mk v).is_continuous_iff, },
  { apply forall_congr,
    intro r,
    simpa using (out_mk v) (algebra_map A r) 1, }
end

namespace spa

variable {A : Huber_pair}

instance : has_coe (spa A) (Spv A) := ‚ü®subtype.val‚ü©

-- Warning. We do not use the basic open sets to define the topology on spa.
-- For more details, see the explanation in TODO.

/-- The basic open sets in spa A generate a topology
that is provably equal to the topology generated by the rational open sets.
We use the latter, and do not prove the equality of these topologies. -/
definition basic_open (r s : A) : set (spa A) :=
{v | v r ‚â§ v s ‚àß v s ‚â† 0 }

lemma mk_mem_basic_open {r s : A} {v : valuation A Œì‚ÇÄ}
  {hv‚ÇÅ : v.is_continuous} {hv‚ÇÇ : ‚àÄ r : A‚Å∫, v (algebra_map A r) ‚â§ 1} :
  (‚ü®Spv.mk v, mk_mem_spa.mpr ‚ü®hv‚ÇÅ, hv‚ÇÇ‚ü©‚ü© : spa A) ‚àà basic_open r s ‚Üî v r ‚â§ v s ‚àß v s ‚â† 0 :=
begin
  apply and_congr,
  { apply out_mk, },
  { apply (out_mk v).ne_zero, },
end

lemma basic_open_eq (s : A) : basic_open s s = {v | v s ‚â† 0} :=
set.ext $ Œª v, ‚ü®Œª h, h.right, Œª h, ‚ü®le_refl _, h‚ü©‚ü©

-- should only be applied with (Hfin : fintype T) and (Hopen: is_open (span T))
definition rational_open (s : A) (T : set A) : set (spa A) :=
{v | (‚àÄ t ‚àà T, (v t ‚â§ v s)) ‚àß (v s ‚â† 0)}

instance (r : rational_open_data A) : fintype r.T := r.Tfin

namespace rational_open_data

def rational_open (r : rational_open_data A) : set (spa A) :=
rational_open r.s r.T

end rational_open_data -- namespace

/- In this file, we are going to take a projective limit over a preordered set of rings,
   to make a presheaf. The underlying type of this preorder is `rational_open_data A`.-/

-- our preorder is weaker than the preorder we're supposed to have but don't. However
-- the projective limit we take over our preorder is provably (in maths) equal to
-- the projective limit that we cannot even formalise. The thing we definitely need
-- is that if r1 ‚â§ r2 then there's a map localization r1 ‚Üí localization r2

lemma mk_mem_rational_open {s : A} {T : set A} {v : valuation A Œì‚ÇÄ}
  {hv‚ÇÅ : v.is_continuous} {hv‚ÇÇ : ‚àÄ r : A‚Å∫, v (algebra_map A r) ‚â§ 1} :
  (‚ü®Spv.mk v, mk_mem_spa.mpr ‚ü®hv‚ÇÅ, hv‚ÇÇ‚ü©‚ü© : spa A) ‚àà rational_open s T ‚Üî
  (‚àÄ t ‚àà T, (v t ‚â§ v s)) ‚àß (v s ‚â† 0) :=
begin
  apply and_congr,
  { apply forall_congr,
    intro t,
    apply forall_congr,
    intro ht,
    apply out_mk },
  { apply (out_mk v).ne_zero }
end

definition rational_open_bInter (s : A) (T : set A) :
  rational_open s T = (‚ãÇ t ‚àà T, basic_open t s) ‚à© {v | v s ‚â† 0} :=
begin
  ext v,
  split; rintros ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©; split; try { exact h‚ÇÇ },
  { erw set.mem_bInter_iff,
    intros t ht,
    split,
    { exact h‚ÇÅ t ht, },
    { exact h‚ÇÇ } },
  { intros t ht,
    erw set.mem_bInter_iff at h‚ÇÅ,
    exact (h‚ÇÅ t ht).1 }
end

instance (A : Huber_pair) : topological_space (spa A) :=
topological_space.generate_from {U : set (spa A) | ‚àÉ r : rational_open_data A, U = r.rational_open}

@[simp] lemma rational_open_singleton {r s : A} :
rational_open s {r} = basic_open r s :=
begin
  apply le_antisymm; rintros v ‚ü®h‚ÇÅ, h‚ÇÇ‚ü©; split;
  intros; simp [*] at *,
end

@[simp] lemma basic_open_eq_univ : basic_open (1 : A) (1 : A) = univ :=
univ_subset_iff.1 $ Œª v h, ‚ü®le_refl _,by erw valuation.map_one; exact one_ne_zero‚ü©

@[simp] lemma rational_open_eq_univ : rational_open (1 : A) {(1 : A)} = univ :=
by simp

def rational_basis (A : Huber_pair) : set (set (spa A)) :=
{U : set (spa A) | ‚àÉ r : rational_open_data A, U = r.rational_open }

section
open algebra lattice

lemma rational_basis.is_basis.mul (T‚ÇÅ T‚ÇÇ : set A)
  (h‚ÇÅ : is_open (‚Üë(ideal.span T‚ÇÅ) : set A)) (h‚ÇÇ : is_open (‚Üë(ideal.span T‚ÇÇ) : set A)) :
  is_open (‚Üë(ideal.span (T‚ÇÅ * T‚ÇÇ)) : set A) :=
begin
  rcases Huber_ring.exists_pod_subset _ (mem_nhds_sets h‚ÇÅ $ ideal.zero_mem $ ideal.span T‚ÇÅ)
    with ‚ü®A‚ÇÄ, _, _, _, ‚ü®_, emb, I, fg, top‚ü©, hI‚ü©,
  dsimp only at hI,
  resetI,
  rw is_ideal_adic_iff at top,
  cases top.2 (algebra_map A ‚Åª¬π' ‚Üë(ideal.span T‚ÇÇ)) _ with n hn,
  { apply submodule.is_open_of_open_submodule,
    use ideal.map (of_id A‚ÇÄ A) (I^(n+1)),
    refine ‚ü®is_open_ideal_map_open_embedding emb _ (top.1 (n+1)), _‚ü©,
    delta ideal.span,
    erw [pow_succ, ideal.map_mul, ‚Üê submodule.span_mul_span],
    apply submodule.mul_le_mul,
    { exact (ideal.span_le.mpr hI) },
    { rw ‚Üê image_subset_iff at hn,
      exact (ideal.span_le.mpr hn) } },
  { apply emb.continuous.tendsto,
    rw show algebra.to_fun A (0:A‚ÇÄ) = 0,
    { apply is_ring_hom.map_zero },
    exact (mem_nhds_sets h‚ÇÇ $ ideal.zero_mem $ ideal.span T‚ÇÇ) }
end

end

namespace rational_open_data

end rational_open_data

lemma rational_basis.is_basis.pow (T : set A) (hT : is_open (‚Üë(ideal.span T) : set A)) (n : ‚Ñï) :
  is_open (‚Üë(ideal.span (T^n)) : set A) :=
begin
  induction n with n ih,
  { erw [pow_zero, ideal.span_singleton_one], exact is_open_univ },
  { rw pow_succ, exact rational_basis.is_basis.mul _ _ hT ih }
end

variable (A)

variable {A}

section
open topological_space

def rational_open_data_subsets (U : opens (spa A)) :=
{ r : rational_open_data A // r.rational_open ‚äÜ U}
def rational_open_data_subsets.map {U V : opens (spa A)} (hUV : U ‚â§ V)
  (rd : rational_open_data_subsets U) :
  rational_open_data_subsets V :=
‚ü®rd.val, set.subset.trans rd.property hUV‚ü©

noncomputable def rational_open_data_subsets_inter {U :  opens (spa A)}
  (r1 r2 : rational_open_data_subsets U) :
rational_open_data_subsets U :=
‚ü®rational_open_data.inter r1.1 r2.1, begin
  rw rational_open_data.rational_open_data_inter,
  refine set.subset.trans (inter_subset_left r1.1.rational_open r2.1.rational_open) _,
  exact r1.2
end‚ü©

lemma rational_open_data_subsets_symm {U :  opens (spa A)}
  (r1 r2 : rational_open_data_subsets U) :
rational_open_data_subsets_inter r1 r2 = rational_open_data_subsets_inter r2 r1 :=
begin
  rw subtype.ext,
  exact rational_open_data.rational_open_data_symm r1.1 r2.1
end

instance (r : rational_open_data A) : uniform_space (rational_open_data.localization r) :=
topological_add_group.to_uniform_space _

instance (rd : rational_open_data A): uniform_add_group (rational_open_data.localization rd) :=
topological_add_group_is_uniform

def localization_map_is_uniform_continuous {r1 r2 : rational_open_data A} (h : r1 ‚â§ r2) :
  uniform_continuous (rational_open_data.localization_map h) :=
uniform_continuous_of_continuous (rational_open_data.localization_map_is_cts h)

end -- section

open uniform_space

-- rat_open_data is short for "rational open data". KB needs to think more clearly
-- about namespaces etc.
/-- A<T/s>, the functions on D(T,s). A topological ring -/
def rat_open_data_completion (r : rational_open_data A) :=
completion (rational_open_data.localization r)

namespace rat_open_data_completion
open topological_space

noncomputable instance (r : rational_open_data A) : comm_ring (rat_open_data_completion r) :=
by dunfold rat_open_data_completion; apply_instance

instance uniform_space (r : rational_open_data A) : uniform_space (rat_open_data_completion r) :=
by dunfold rat_open_data_completion; apply_instance

instance (r : rational_open_data A) : topological_ring (rat_open_data_completion r) :=
by dunfold rat_open_data_completion; apply_instance

noncomputable def restriction {r1 r2 : rational_open_data A} (h : r1 ‚â§ r2) :
rat_open_data_completion r1 ‚Üí rat_open_data_completion r2 :=
completion.map (rational_open_data.localization_map h)

instance restriction_is_ring_hom {r1 r2 : rational_open_data A} (h : r1 ‚â§ r2) :
  is_ring_hom (restriction h) :=
completion.is_ring_hom_map (rational_open_data.localization_map_is_cts h)

lemma restriction_is_uniform_continuous {r1 r2 : rational_open_data A} (h : r1 ‚â§ r2) :
uniform_continuous (rat_open_data_completion.restriction h) :=
completion.uniform_continuous_map

end rat_open_data_completion -- namespace

open topological_space

/-- The underlying type of ùí™_X(U), the structure presheaf on Spa(A) -/
def presheaf_value (U : opens (spa A)) :=
{f : Œ† (rd : rational_open_data_subsets U), rat_open_data_completion rd.1 //
   ‚àÄ (rd1 rd2 : rational_open_data_subsets U) (h : rd1.1 ‚â§ rd2.1),
     rat_open_data_completion.restriction h (f rd1) = (f rd2)} -- agrees on overlaps

def presheaf_value_set (U : opens (spa A)) :=
{f : Œ† (rd : rational_open_data_subsets U), rat_open_data_completion rd.1 |
   ‚àÄ (rd1 rd2 : rational_open_data_subsets U) (h : rd1.1 ‚â§ rd2.1),
     rat_open_data_completion.restriction h (f rd1) = (f rd2)}

-- We need to check it's a ring


instance presheaf_subring (U : opens (spa A)) : is_subring (presheaf_value_set U) :=
begin
refine {..},
  { -- zero_mem
    intros rd‚ÇÅ rd‚ÇÇ h,
    exact is_ring_hom.map_zero _ },
  { -- add_mem
    intros a b ha hb rd‚ÇÅ rd‚ÇÇ h,
    change rat_open_data_completion.restriction h (a rd‚ÇÅ + b rd‚ÇÅ) = a rd‚ÇÇ + b rd‚ÇÇ,
    rw is_ring_hom.map_add (rat_open_data_completion.restriction h),
    rw [ha _ _ h, hb _ _ h] },
  { -- neg_mem
    intros a ha rd‚ÇÅ rd‚ÇÇ h,
    change rat_open_data_completion.restriction h (-(a rd‚ÇÅ)) = -(a rd‚ÇÇ),
    rw is_ring_hom.map_neg (rat_open_data_completion.restriction h),
    rw ha _ _ h },
  { -- one_mem
    intros rd‚ÇÅ rd‚ÇÇ h,
    exact is_ring_hom.map_one _ },
  { -- mul_mem
    intros a b ha hb rd‚ÇÅ rd‚ÇÇ h,
    change rat_open_data_completion.restriction h (a rd‚ÇÅ * b rd‚ÇÅ) = a rd‚ÇÇ * b rd‚ÇÇ,
    rw is_ring_hom.map_mul (rat_open_data_completion.restriction h),
    rw [ha _ _ h, hb _ _ h] }
end

noncomputable instance presheaf_comm_ring (U : opens (spa A)) : comm_ring (presheaf_value U) :=
begin
  apply @subset.comm_ring _ pi.comm_ring _ _, apply_instance,
  exact spa.presheaf_subring U
end

instance presheaf_top_space (U : opens (spa A)) : topological_space (presheaf_value U) :=
by unfold presheaf_value; apply_instance

example (U : opens (spa A)) :
  topological_ring (Œ† (rd : rational_open_data_subsets U), rat_open_data_completion (rd.1)) :=
by apply_instance

-- tactic mode because I can't get Lean to behave. Note: switching to tactic
-- mode indicated the problem was that Lean was not finding the two instances I flag
-- with haveI and letI; probably now I know this one could try to go back into term mode.
instance presheaf_top_ring (U : opens (spa A)) : topological_ring (presheaf_value U) :=
begin
  haveI := spa.presheaf_subring U,
  letI : topological_ring (Œ† (rd : rational_open_data_subsets U), rat_open_data_completion (rd.1)) :=
    by apply_instance,
  apply topological_subring (presheaf_value_set U),
end

instance (U : opens (spa A)) (r : rational_open_data_subsets U) :
  is_ring_hom (Œª (f : presheaf_value U), f.val r) :=
{ map_one := rfl,
  map_mul := Œª _ _, rfl,
  map_add := Œª _ _, rfl }

-- note the (X : _) trick, which tells Lean "don't try and
-- elaborate X assuming it has the type you know it has,
-- elaborate it independently, figure out the type, and
-- then unify". Thanks to Mario Carneiro for this trick which
-- hugely speeds up elaboration time of this definition.
def presheaf_map {U V : opens (spa A)} (hUV : U ‚â§ V) :
  presheaf_value V ‚Üí presheaf_value U :=
Œª f, ‚ü®_, Œª rd1 rd2 h,
  (f.2 (rational_open_data_subsets.map hUV rd1)
    (rational_open_data_subsets.map hUV rd2) h : _)‚ü©

lemma presheaf_map_id (U : opens (spa A)) :
  presheaf_map (le_refl U) = id :=
by { delta presheaf_map, tidy }

lemma presheaf_map_comp {U V W : opens (spa A)} (hUV : U ‚â§ V) (hVW : V ‚â§ W) :
  presheaf_map hUV ‚àò presheaf_map hVW = presheaf_map (le_trans hUV hVW) :=
by { delta presheaf_map, tidy }

instance presheaf_map_is_ring_hom {U V : opens (spa A)} (hUV : U ‚â§ V) :
is_ring_hom (presheaf_map hUV) :=
{ map_one := rfl,
  map_mul := Œª _ _, rfl,
  map_add := Œª _ _, rfl }

def presheaf_map_cts {U V : opens (spa A)} (hUV : U ‚â§ V) :
  continuous (presheaf_map hUV) :=
continuous_subtype_mk _ (continuous_pi (Œª i, ((continuous_apply _).comp continuous_subtype_val)))

variable (A)
noncomputable def presheaf_of_topological_rings : presheaf_of_topological_rings (spa A) :=
{ F := presheaf_value,
  res := Œª U V, presheaf_map,
  Hid := presheaf_map_id,
  Hcomp := Œª U V W, presheaf_map_comp,
  Fring := spa.presheaf_comm_ring,
  res_is_ring_hom := Œª U V, spa.presheaf_map_is_ring_hom,
  Ftop := spa.presheaf_top_space,
  Ftop_ring := spa.presheaf_top_ring,
  res_continuous := Œª U V, presheaf_map_cts
}


end spa -- namespace I think

-- old notes

-- remember that a rational open is not actually `rational_open s T` in full
-- generality -- we also need that T is finite and that T generates an open ideal in A.
-- The construction on p73/74 (note typo in first line of p74 -- ideal should be I.D)
-- gives A<T/s> (need completion) and A<T/s>^+ (need integral closure).

-- KB idle comment: I guess we never make A<T/s> a Huber pair if A is a Huber pair?
-- We would need integral closure for this and I don't think we have it in mathlib.

-- We see mid way through p75 that the definition of the presheaf
-- on V is proj lim of O_X(U) as U runs through rationals opens in V. This gets
-- the projective limit topology and then we have a presheaf (hopefully this is
-- straightforward) of complete topological rings (need proj lim of complete is complete)
